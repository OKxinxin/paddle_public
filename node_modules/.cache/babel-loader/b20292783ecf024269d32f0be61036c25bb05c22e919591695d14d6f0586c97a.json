{"ast":null,"code":"import { resolveComponent as _resolveComponent, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  ref: \"container\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_DisPwin = _resolveComponent(\"DisPwin\");\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createVNode(_component_DisPwin, {\n    niiGzPath: $props.niiGzPath,\n    labelPath: $props.labelPath\n  }, null, 8 /* PROPS */, [\"niiGzPath\", \"labelPath\"])], 512 /* NEED_PATCH */);\n}","map":{"version":3,"names":["ref","_createElementBlock","_hoisted_1","_createVNode","_component_DisPwin","niiGzPath","$props","labelPath"],"sources":["E:\\HomeWork\\百度飞浆\\medical_0.1.0\\src\\components\\Display\\display.vue"],"sourcesContent":["<template>\r\n  <div ref=\"container\">\r\n    <DisPwin :niiGzPath=\"niiGzPath\" :labelPath=\"labelPath\"></DisPwin>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport DisPwin from './dis.vue';\r\nimport * as THREE from 'three';\r\n\r\nexport default {\r\n  name: 'Display_win',\r\n\r\n  components: {\r\n    DisPwin,\r\n  },\r\n\r\n\r\n  props: {\r\n    niiGzPath: {\r\n      type: String,\r\n      required: true\r\n    },\r\n    labelPath: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  },\r\n  mounted() {\r\n    this.initScene();\r\n    this.loadData();\r\n    this.loadLabelData();\r\n    this.addViews();\r\n    this.animate();\r\n  },\r\n  methods: {\r\n    initScene() {\r\n      this.scene = new THREE.Scene();\r\n      this.camera = new THREE.PerspectiveCamera(\r\n        45,\r\n        this.$refs.container.offsetWidth / this.$refs.container.offsetHeight,\r\n        0.1,\r\n        1000\r\n      );\r\n      this.renderer = new THREE.WebGLRenderer();\r\n      this.renderer.setSize(\r\n        this.$refs.container.offsetWidth,\r\n        this.$refs.container.offsetHeight\r\n      );\r\n      this.$refs.container.appendChild(this.renderer.domElement);\r\n    },\r\n\r\n    loadData() {\r\n      const loader = new THREE.NIFTIReader();\r\n      loader.load(this.niiGzPath, nifti => {\r\n        const data = nifti.getData();\r\n        const geometry = new THREE.BoxGeometry(nifti.hdr.dims[1], nifti.hdr.dims[2], nifti.hdr.dims[3]);\r\n        const texture = new THREE.DataTexture3D(data, nifti.hdr.dims[1], nifti.hdr.dims[2], nifti.hdr.dims[3]);\r\n        texture.format = THREE.RedFormat;\r\n        const material = new THREE.ShaderMaterial({\r\n          uniforms: {\r\n            u_tex: { value: texture },\r\n          },\r\n          vertexShader: `\r\n            varying vec3 v_position;\r\n            void main() {\r\n              v_position = position;\r\n              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n            }\r\n          `,\r\n          fragmentShader: `\r\n            varying vec3 v_position;\r\n            uniform sampler3D u_tex;\r\n            void main() {\r\n              vec3 coord = vec3(v_position.x, v_position.y, v_position.z);\r\n              gl_FragColor = texture(u_tex, coord);\r\n            }\r\n          `,\r\n        });\r\n        const cube = new THREE.Mesh(geometry, material);\r\n        this.cube = cube;\r\n        this.scene.add(this.cube);\r\n      });\r\n    },\r\n\r\n    loadLabelData() {\r\n      const labelLoader = new THREE.NIFTIReader();\r\n      labelLoader.load(this.labelPath, nifti => {\r\n        const data = nifti.getData();\r\n        const geometry = new THREE.BoxGeometry(nifti.hdr.dims[1], nifti.hdr.dims[2], nifti.hdr.dims[3]);\r\n        const texture = new THREE.DataTexture3D(data, nifti.hdr.dims[1], nifti.hdr.dims[2], nifti.hdr.dims[3]);\r\n        texture.format = THREE.RedFormat;\r\n        const material = new THREE.ShaderMaterial({\r\n          uniforms: {\r\n            u_tex: { value: texture },\r\n          },\r\n          vertexShader: `\r\n            varying vec3 v_position;\r\n            void main() {\r\n              v_position = position;\r\n              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n            }\r\n          `,\r\n          fragmentShader: `\r\n            varying vec3 v_position;\r\n            uniform sampler3D u_tex;\r\n            void main() {\r\n              vec3 coord = vec3(v_position.x, v_position.y, v_position.z);\r\n              gl_FragColor = texture(u_tex, coord);\r\n            }\r\n          `,\r\n        });\r\n        const cube = new THREE.Mesh(geometry, material);\r\n        this.labelCube = cube;\r\n        this.labelCube.position.x = nifti.hdr.dims[1] + 1;\r\n        this.scene.add(this.labelCube);\r\n      });\r\n    },\r\n\r\n    addViews() {\r\n      const views = [\r\n        {\r\n          left: 0,\r\n          bottom: 0,\r\n          width: 0.5,\r\n          height: 0.5,\r\n          eye: [0, 0, 800],\r\n          up: [0, 1, 0],\r\n          background: new THREE.Color().setRGB(0.5, 0.5, 0.7),\r\n          fov: 45,\r\n        },\r\n        {\r\n          left: 0.5,\r\n          bottom: 0,\r\n          width: 0.5,\r\n          height: 0.5,\r\n          eye: [0, 800, 0],\r\n          up: [0, 0, -1],\r\n          background: new THREE.Color().setRGB(0.7, 0.5, 0.5),\r\n          fov: 45,\r\n        },\r\n        {\r\n          left: 0,\r\n          bottom: 0.5,\r\n          width: 0.5,\r\n          height: 0.5,\r\n          eye: [800, 0, 0],\r\n          up: [0, 0, -1],\r\n          background: new THREE.Color().setRGB(0.7, 0.7, 0.5),\r\n          fov: 45,\r\n        },\r\n      ];\r\n      this.views = views.map(view => {\r\n        const camera = new THREE.PerspectiveCamera(\r\n          view.fov,\r\n          this.$refs.container.offsetWidth / this.$refs.container.offsetHeight,\r\n          0.1,\r\n          1000\r\n        );\r\n        camera.up.fromArray(view.up);\r\n        camera.position.fromArray(view.eye);\r\n        const scene = new THREE.Scene();\r\n        scene.background = view.background;\r\n        scene.add(this.cube.clone());\r\n        scene.add(this.labelCube.clone());\r\n        const _width = this.$refs.container.offsetWidth * view.width;\r\n        const _height = this.$refs.container.offsetHeight * view.height;\r\n        const left = this.$refs.container.offsetWidth * view.left;\r\n        const bottom = this.$refs.container.offsetHeight * view.bottom;\r\n        return {\r\n          left,\r\n          bottom,\r\n          width: _width,\r\n          height: _height,\r\n          camera,\r\n          scene,\r\n        };\r\n      });\r\n      this.currentView = this.views[0];\r\n    },\r\n\r\n    animate() {\r\n      requestAnimationFrame(this.animate);\r\n      // 在这里更新和渲染场景\r\n      this.cube.rotation.x += 0.01;\r\n      this.cube.rotation.y += 0.01;\r\n      this.labelCube.rotation.x += 0.01;\r\n      this.labelCube.rotation.y += 0.01;\r\n\r\n      this.views.forEach(({ left, bottom, width, height, camera, scene }) => {\r\n        this.renderer.setViewport(left, bottom, width, height);\r\n        this.renderer.setScissor(left, bottom, width, height);\r\n        this.renderer.setScissorTest(true);\r\n        camera.aspect = width / height;\r\n        camera.updateProjectionMatrix();\r\n        this.renderer.render(scene, camera);\r\n      });\r\n    },\r\n  },\r\n};\r\n</script>\r\n\r\n<style scoped>\r\n\r\n</style>"],"mappings":";;EACOA,GAAG,EAAC;AAAW;;;uBAApBC,mBAAA,CAEM,OAFNC,UAEM,GADJC,YAAA,CAAiEC,kBAAA;IAAvDC,SAAS,EAAEC,MAAA,CAAAD,SAAS;IAAGE,SAAS,EAAED,MAAA,CAAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}